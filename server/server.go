package server

import (
	"fmt"
	"io"
	"log"
	"net"
	"runtime"

	"github.com/spf13/viper"
	"github.com/talbright/keds/events"
	pb "github.com/talbright/keds/gen/proto"
	"github.com/talbright/keds/plugin"
	ut "github.com/talbright/keds/utils/token"
	"golang.org/x/net/context"
	"golang.org/x/net/trace"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

const (
	gRPCEndPoint = "localhost:50051"
)

//RegisterPlugin implements the gRPC interface for keds.proto
type KedsRPCServer struct {
	server   *grpc.Server
	listener *ServerListener
	events   trace.EventLog
	bus      events.IEventBus
	loader   ILoader
	Cobra    *Cobra
}

func NewKedsRPCServer() *KedsRPCServer {
	_, file, line, _ := runtime.Caller(0)
	self := &KedsRPCServer{
		server: grpc.NewServer(),
		bus:    events.NewEventBus(),
		loader: NewLoader(viper.GetStringSlice("plugin_path")),
		events: trace.NewEventLog("server.KedsRPCServer", fmt.Sprintf("%s:%d", file, line)),
	}
	self.listener = NewServerListener(self.bus, self)
	self.bus.AddListener(context.Background(), self.listener)
	return self
}

//RegisterPlugin gRPC interface method implementation
//plugins must be registered first before invoking other methods
func (s *KedsRPCServer) RegisterPlugin(ctx context.Context, req *pb.RegisterPluginRequest) (resp *pb.RegisterPluginResponse, err error) {
	plug := plugin.NewPlugin(req.GetPluginDescriptor())
	if err = plugin.DefaultRegistry().Register(ut.AddTokenToContext(ctx, plug.GetSha1()), plug); err != nil {
		s.events.Errorf("failed to register plugin: %v", err)
	} else {
		s.events.Printf("registered %s", plug)
		ut.AddTokenToHeader(ctx, plug.GetSha1())
		s.Cobra.AddPlugin(ctx, plug, s.bus)
	}
	return &pb.RegisterPluginResponse{}, err
}

//ConsoleWriter gRPC interface method implementation
//Inbound only stream allows clients to write to the console (STDOUT)
func (s *KedsRPCServer) ConsoleWriter(stream pb.KedsService_ConsoleWriterServer) error {
	if _, err := s.validateToken(stream.Context()); err != nil {
		return err
	}
	for {
		if output, err := stream.Recv(); err == nil {
			log.Printf("%s", output.GetData())
		} else if err == io.EOF {
			return stream.SendAndClose(&pb.ConsoleWriteResponse{})
		} else {
			s.events.Errorf("failed to receive from stream: %v", err)
			return err
		}
	}
}

//EventBus gRPC interface method implementation
//Inbound and outbound stream that allows plugins to send and receive events
//generated by other plugins or the server.
func (s *KedsRPCServer) EventBus(stream pb.KedsService_EventBusServer) (err error) {
	var plug *plugin.Plugin
	if plug, err = s.validateToken(stream.Context()); err != nil {
		return err
	}
	var quitc chan struct{}
	listener := NewStreamListener(s.bus, stream, plug.GetName())
	if quitc, err = s.bus.AddListener(stream.Context(), listener); err != nil {
		s.events.Errorf("failed to add stream: %v", err)
	} else {
		<-quitc
		if err = plugin.DefaultRegistry().Unregister(stream.Context()); err != nil {
			s.events.Errorf("failed to unregister plugin: %v", err)
		}
	}
	return
}

func (s *KedsRPCServer) validateToken(ctx context.Context) (plug *plugin.Plugin, err error) {
	plug, err = plugin.DefaultRegistry().GetFromContext(ctx)
	return
}

func (s *KedsRPCServer) Start() {
	go StartDebugServer()
	log.Printf("starting plugins")
	s.loader.Load()
	log.Printf("starting rpc server on %s", gRPCEndPoint)
	lis, err := net.Listen("tcp", gRPCEndPoint)
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	pb.RegisterKedsServiceServer(s.server, s)
	reflection.Register(s.server)
	if err := s.server.Serve(lis); err != nil {
		log.Fatalf("failed to start RPC server: %v", err)
	}
	log.Printf("stopped rpc server")
}
