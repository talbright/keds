package server

import (
	"fmt"
	"io"
	"log"
	"net"
	"time"

	pb "github.com/talbright/keds/gen/proto"
	. "github.com/talbright/keds/plugin"
	"golang.org/x/net/context"
	"golang.org/x/net/trace"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

const (
	gRPCPort     = ":50051"
	gRPCEndPoint = "localhost:50051"
	proxyPort    = ":8080"
)

//RegisterPlugin implements gRPC interface
type KedsRPCServer struct {
	server          *grpc.Server
	Plugins         IPluginRegistry
	EventBusAdapter IEventBusAdapter
}

//RegisterPlugin gRPC interface method implementation
//plugins must be registered first before invoking other methods
func (s *KedsRPCServer) RegisterPlugin(ctx context.Context, req *pb.RegisterPluginRequest) (*pb.RegisterPluginResponse, error) {
	trace.FromContext(ctx)
	plugin := NewPluginFromRegisterPluginRequest(req)
	err := s.Plugins.RegisterPlugin(ctx, plugin)
	return &pb.RegisterPluginResponse{Signature: plugin.GetSha1()}, err
}

//ConsolWriter gRPC interface method implmentation
//allows clients to write to the console (STDOUT)
func (s *KedsRPCServer) ConsoleWriter(stream pb.KedsService_ConsoleWriterServer) error {
	for {
		if output, err := stream.Recv(); err == nil {
			log.Printf("[%s] %s", output.GetSignature(), output.GetData())
		} else if err == io.EOF {
			return stream.SendAndClose(&pb.ConsoleWriteResponse{})
		} else {
			return err
		}
	}
}

//EventBus gRPC interface method implmentation
//allows plugins to send and receive events generated by other plugins or
//the server
func (s *KedsRPCServer) EventBus(stream pb.KedsService_EventBusServer) error {
	if quitc, err := s.EventBusAdapter.AddStream(context.Background(), stream); err != nil {
		log.Printf("failed to add stream: %v", err)
	} else {
		go func() {
			for i := 0; i < 3; i++ {
				e := &pb.PluginEvent{
					Name:   fmt.Sprintf("core:event%d", i),
					Source: "core",
				}
				s.EventBusAdapter.Publish(context.Background(), e)
				time.Sleep(5 * time.Second)
			}
		}()
		log.Printf("waiting for quit chan to close")
		<-quitc
		log.Printf("quit chan closed")
	}
	return nil
}

func (s *KedsRPCServer) Start() {
	go StartDebugServer()
	log.Printf("starting rpc server on %s", gRPCEndPoint)
	lis, err := net.Listen("tcp", gRPCPort)
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	s.server = grpc.NewServer()
	pb.RegisterKedsServiceServer(s.server, s)
	reflection.Register(s.server)
	if err := s.server.Serve(lis); err != nil {
		log.Fatalf("failed to start RPC server: %v", err)
	}
	log.Printf("stopped rpc server")
}
