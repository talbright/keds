package server

import (
	"fmt"
	"io"
	"log"
	"net"
	"runtime"

	"github.com/spf13/viper"
	pb "github.com/talbright/keds/gen/proto"
	. "github.com/talbright/keds/plugin"
	ut "github.com/talbright/keds/utils/token"
	"golang.org/x/net/context"
	"golang.org/x/net/trace"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

const (
	gRPCPort     = ":50051"
	gRPCEndPoint = "localhost:50051"
	proxyPort    = ":8080"
)

//RegisterPlugin implements the gRPC interface for keds.proto
type KedsRPCServer struct {
	server *grpc.Server
	events trace.EventLog
	bus    IEventBusAdapter
	loader ILoader
}

func NewKedsRPCServer() *KedsRPCServer {
	_, file, line, _ := runtime.Caller(0)
	return &KedsRPCServer{
		server: grpc.NewServer(),
		bus:    NewEventBus(),
		loader: NewLoader(viper.GetStringSlice("plugin_path")),
		events: trace.NewEventLog("server.KedsRPCServer", fmt.Sprintf("%s:%d", file, line)),
	}
}

//RegisterPlugin gRPC interface method implementation
//plugins must be registered first before invoking other methods
func (s *KedsRPCServer) RegisterPlugin(ctx context.Context, req *pb.RegisterPluginRequest) (resp *pb.RegisterPluginResponse, err error) {
	plugin := NewPluginFromRegisterPluginRequest(req)
	if err = DefaultRegistry().RegisterPlugin(ut.AddTokenToContext(ctx, plugin.GetSha1()), plugin); err != nil {
		s.events.Errorf("failed to register plugin: %v", err)
	} else {
		s.events.Printf("registered %s", plugin)
		ut.AddTokenToHeader(ctx, plugin.GetSha1())
	}
	return &pb.RegisterPluginResponse{}, err
}

//ConsolWriter gRPC interface method implementation
//Inbound only stream allows clients to write to the console (STDOUT)
func (s *KedsRPCServer) ConsoleWriter(stream pb.KedsService_ConsoleWriterServer) error {
	if err := s.validateToken(stream.Context()); err != nil {
		return err
	}
	for {
		if output, err := stream.Recv(); err == nil {
			log.Printf("%s", output.GetData())
		} else if err == io.EOF {
			return stream.SendAndClose(&pb.ConsoleWriteResponse{})
		} else {
			s.events.Errorf("failed to receive from stream: %v", err)
			return err
		}
	}
}

//EventBus gRPC interface method implementation
//Inbound and outbound stream that allows plugins to send and receive events
//generated by other plugins or the server.
func (s *KedsRPCServer) EventBus(stream pb.KedsService_EventBusServer) (err error) {
	if err := s.validateToken(stream.Context()); err != nil {
		return err
	}
	var quitc chan struct{}
	if quitc, err = s.bus.AddStream(stream.Context(), stream); err != nil {
		s.events.Errorf("failed to add stream: %v", err)
	} else {
		<-quitc
		if err = DefaultRegistry().UnRegisterPlugin(stream.Context()); err != nil {
			s.events.Errorf("failed to unregister plugin: %v", err)
		}
	}
	return
}

func (s *KedsRPCServer) validateToken(ctx context.Context) (err error) {
	_, err = DefaultRegistry().GetPluginFromContext(ctx)
	return
}

func (s *KedsRPCServer) Start() {
	go StartDebugServer()
	log.Printf("starting plugins")
	s.loader.Load()
	log.Printf("starting rpc server on %s", gRPCEndPoint)
	lis, err := net.Listen("tcp", gRPCPort)
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	pb.RegisterKedsServiceServer(s.server, s)
	reflection.Register(s.server)
	if err := s.server.Serve(lis); err != nil {
		log.Fatalf("failed to start RPC server: %v", err)
	}
	log.Printf("stopped rpc server")
}
